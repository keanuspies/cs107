NAME(s) 
Renner Leite Lucena && Keanu Phillip Spies

DESIGN 
<Give an overview of your allocator implementation (what data structures/algorithms/features)>
Me and my partner made the following decisions: First, our blocks of memory are all multiples of 8. They can have 3 categories - used block, free block or garbage. All of them store a struct header of 8 bytes, containing two variables unsigned int of 4 bytes - payloadsz and prevpayloadsz. In the payloadsz, given the multiplicity of 8, we have 3 bits that can be used - the leftmost one and the two rightmost ones (the same is true for prevpayloadsz, but we do not use them). The first one stores if the block is free or not, the second one (penultimate bit) if the block above in memory (next block) is free or not (if this block exists) and the third one (last bit) if the block below in memory (previous block) is free or not (if this block exists). Used and free blocks have at least 24 bytes, 8 for the header and 16 important especially for free blocks - the first 8 ones store a pointer to the next free block if it exists, while the second 8 ones store a pointer to the previous free block if it exists. Garbage, otherwise, have 8 or 16 bytes - a header and 0 or 8 of payloadsz. It has status of a free block (the leftmost bit of its variable payloadsz in the header is set), but it is not part of our free list, since, besides the header, it does not have space for 2 pointers (16 bytes). Our implementation also has 3 global variables - a "buckets" array of pointers called "buckets", whose pointers point to specific elements of our freeList, making the access to groups of them, determined by powers of 2 in relation to their sizes, faster; a pointer to the first block in memory, called "min_block"; and a pointer to the last block in memory, named "max_block".

Whenever the user tries to malloc some space in memory, first we look for a block in the free list that has enough space for the size he wants. This search starts in a determined portion of the list, which is created by comparing the size of the block requested, rounded up to a multiple of 8, to the powers of 2 (a requested size of 23 would become 24, and when freed, it would become part the group of sizes between 16 and 32, whose partial linked list of free blocks contains all the ones with sizes in such range, having its header pointer saved in the buckets array). If nothing is found, we create a new space for the user, calling more pages of memory. Any remainder space, either in a found free block or in new pages of memory, is set free, being added to the free list if it is not garbage (has at least 24 bytes). Realloc is very similar - if the new size of the reallocation is smaller than the oldsize, the remainder is set free then added to the free list if it is not garbage; if it is larger, we analyze if there is any free block above it in memory so that the requested size fits, setting free if any remainder exists, adding it to the free list if it is not garbage. The free function sets the block given to it as free, and also does coalision with any free space above or below this space provided. All the time, in these operations, the block in consideration and the ones above and below it are changed to have the right information about their previous and next ones (if they are free or not, and have the right prevpayloadsz and payloadsz).

RATIONALE 
<Provide rationale for your design choices. Describe motivation for the initial selection of base design and support for the choices in parameters and features incorporated in the final design.>
We decided to have blocks of 8 bytes because, even though some utilization may be lost this way, everything was aligned naturally, and checking operations that would take time became unnecessary. Blocks with headers containing payloadsz and prevpayloadsz help a lot with coalision, allowing us to go to the other blocks above and below easily. Used blocks of at least 24 bytes guarantee that whenever they are freed, we can set the pointers to the next and previous free ones quickly (besides having the header). Our vector of buckets to access freed elements faster was motivated by the idea of hashmaps.  

OPTIMIZATION 
<Describe how you optimized-- what tools/strategies, where your big gains came from. Include at least one specific example of introducing a targeted change with supporting before/after data to demonstrate the (in)effectiveness of your efforts.>
The most important optimizations that we did was to implement the buckets list of free blocks, to make realloc, when the new size is larger than the oldsize, go up and check if there is enough space up there to fit new size, and coalision of free blocks. We knew that coalision was a big change that would increase our utilization a lot, reducing free unused spaces, and also throughput, avoiding calling new pages, looking for free blocks in the free list, and cutting some operations to make previous and next blocks have the right information of their adjacent ones. Part of it came from talking with friends that took the class before, part reading how coalision works in a book. After we implemented it, the performance that we got showed that, indeed, coalision was something important to be implemented.

EVALUATION 
<Give strengths/weaknesses of your final version. What are the characteristics of the workloads it performs well (and not as well) on? What are most promising opportunities for future enhancements?>
Strengths are: utilization is high due to coalescion and segregated freelists, which allow for maginitude access of free blocks to allow us to use among the smallest possible fit for a given size. Optimization: using orderdered access lists of free space in the segregated free list. It works well on data that is random or called in increasing size of free blocks which will allow us to traverse through our free lits in order and access the smallest possible size in the lists for a given requested size. This then is our biggest weakness as well as given frees in decreasing order of magnitude, our buckets will give the biggest block to a request of any size (and in the penultimate worst case the smallest value in the range specified by that block). 

WHAT WOULD YOU LIKE TO TELL US ABOUT YOUR PROJECT?
<Of what are you particularly proud: the effort you put into it? the results you obtained? the process you followed? what you learned along the way? Tell us about it! We are not scoring this section of the readme, but what you offer here provides context for the grader who is reviewing your work. Share with us what you think we should know!>
Everything was awesome. It was a lot of work indeed, a really challenging assignment, but now that everything is working so quickly and efficiently, we feel really proud. The time that we put into it paid back, and the learning that we had was very relevant as well. 

REFERENCES
<If any external resources (books, websites, people) were influential in shaping your design, they must be properly cited here>
Friends: Michael Karr and Jake Heiser with general ideas about their own heap allocator.
Book: B&O is Computer Systems (Bryant and O'Hallaron) with good explanation and insights about coalision.


